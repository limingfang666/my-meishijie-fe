功能：
1:首页banner
2:首页菜单显示及下拉加载
3：登录
	用户名、密码验证
	登录结果
		登录失败，弹窗警告
		登录成功
			后台返回结果及token，并将token存入localStorage中；
			将登录后的用户信息存入vuex中，并通过getters监控数据登录与否变化
			跳转到home页面；
			注意防止页面控制台伪造token攻击
4：页面鉴权
	路由中有设置login:true
	所有地址通过to.name检验是否需要登录
		不需要登录
			直接进入路由地址
		需要登录（通过token和每次发送请求验证是否登录）
			已登录且token通过
				如果路由地址为/login 直接跳转到Home页面
				如果为其他路由地址直接跳转到对应地址
			未登录或者token过期，跳转到login页面

5：登录信息展示：页面header显示用户名、头像等登录信息	
6：注册：用户名、密码校验；用户名重复校验
7：登出：点击退出，弹窗是否真的退出，确认后发送login out请求
8：个人空间（自己/他人空间）
	自己空间不显示收藏与否图标（userId发送请求数据和userId做对比进行区分）
	他人空间：展示是否关注按钮
	
	点击关注/取消关注（注意需要同步更新userInfo信息）
	
	tab双向绑定个人空间子页面（作品、关注、粉丝、收藏）
	自己空间和他人空间，子页面信息展示不一样
		自己空间：
			不展示收藏、关注按钮；可编辑个人资料
		他人空间：
			展示收藏、关注按钮
	通过一句代码实现4个接口数据获取（注意ajax快速切换，数据接收重复问题）
	
9：个人资料编辑（只能编辑自己的资料）：修改用户名、密码、重新上传头像
10：发布菜谱
	数据分为页面展示数据和后端接收数据
	请求菜单分类接口并进行数据展示
	上传菜谱图片
	主料、辅料：封装成同一个组件实现
		默认显示3项（浅拷贝方式实现）
		组件中数据更改，使用双向绑定或者事件监听机制，或者子组件传参
	增加主料辅料
	删除主料辅料
	步骤
		默认显示3项（浅拷贝方式实现）
		上传图片
		增加步骤
		删除步骤（注意key值index复用问题）
	菜谱发布字段校验
	发布按钮（加载中显示）
11：查看菜谱详细信息（收藏与否、评论展示、登录与否）
	header
		点击名字和头像进入个人空间
	content
	commonet
		登录按钮和评论展示（他人和自己空间不一样）
12：收藏按钮显示与否（只显示当前用户userInfo的信息）
13：点击收藏。通过user数据
14：评论
	判断是否登录
	头像为当前用户头像
	获取评论进行展示
	评论并提交
	评论需要进行登录与否校验
15.菜谱大全
	菜谱分类
	筛选：同时根据工艺、口味、难度、人数进行筛选
	分页：上一页、下一页、当前页
	菜谱显示懒加载：loading



自己整理逻辑：
1：根路径访问展示首页
2：首页banner轮播展示（只显示一页的数据）
3：首页菜单显示：首次只展示一页，下拉时，loading展示，然后显示下一页（元素的下边距显示在可视区范围内）
4：注册功能（已有用户名报错，错误信息展示，注册成功信息展示）
5：注册成功后可登录，登录成功后需要记录token,后展示首页，同样展示banner和menu，菜谱大全
6：登录。
路由守卫中判断是否登录：获取登录token
	有token
		有token不能直接判断是否登录成功，需要请求后端返回数据，看是否真的登录成功，如果不成功，需要跳转到login页面
		有token，但路由仍为login，则已经登录成功，直接跳转到Home页面;有token，路由不为login，则直接跳转到当前路由页面	
	没有token且路由（to.name）为login直接进入login页面
	
	没有token，进入的不是login页面，需要跳转到login页面
	
7：退出
	清除token	
8:自定义API。
https://www.cnblogs.com/baizhanshi/p/5776729.html
Web 开发中，除了数据操作之外，最频繁的就是发起和处理各种 HTTP 请求了，加上 HTTP 请求又是异步的，
如果在每个请求中来单独捕获各种常规错误，处理各类自定义错误，那将会有大量的功能类似的代码，
或者使用丑陋的方法在每个请求中调用某几个自定义的函数来处理。这两种方法基本都不是靠谱之选。
主要功能：
Interceptors 有两个处理时机，分别是：
其它程序代码执行 HTTP 请求之后，在实际从浏览器发出请求之前，即处理请求
得到请求的响应之后，在交给其它程序代码处理之前，即处理请求的响应

所以，不难理解它可以用于如下几个方面：

全局处理错误
统一进行身份验证一类的处理
对所有发出去的请求进行预处理
对所有收到的响应进行预处理
做一些增强用户体验的操作，例如显示一个进度条